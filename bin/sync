#!/usr/bin/env node

var fs = require('fs');
var through = require('through2');
var pump = require('pump');
var parseArgs = require('minimist');

var Env = require('../env.js');
var Firebaseref = require('../firebaseref.js');

var Events = require('../sources/events/index.js');
var Employees = require('../sources/employees/index.js');
var Courses = require('../sources/courses/index.js');

var sourcePrototypes = [];

var Report = require('../report/index.js')();

// Based on arguments passed into this process
// populate the sources that will be sync'd.
var args = parseArgs(process.argv.slice(2));
if ((args._.indexOf('help') > -1) ||
    (args._.length === 0)) {
  var usage = fs.readFileSync(
                  __dirname +
                  '/syncUsage.md')
              .toString()
              .replace(/```/g, '\n');
  console.log(usage);
  return;
}
else {
  var largs = args._
                  .map(function (d) {
                      return d.toLowerCase();
                  });

  if (largs.indexOf('events') > -1) {
    sourcePrototypes.push(Events);
  }
  if (largs.indexOf('employees') > -1) {
    sourcePrototypes.push(Employees);
  }
  if (largs.indexOf('courses') > -1) {
    sourcePrototypes.push(Courses);
  }
}

Env();

Firebaseref()
  .pipe(AddEduSyncNodeToFirebase())
  .pipe(Report.config())
  .pipe(ApplySyncProtocolToSources(sourcePrototypes))
  .pipe(GetSourcesData())
  .pipe(AddSourceToWebhook())
  .pipe(RemoveFromWebhookBasedOnSource())
  .pipe(ResolveRelationships())
  .pipe(ResolveReverseRelationships())
  .pipe(Report.update())
  .pipe(Exit());


function AddEduSyncNodeToFirebase () {
  return through.obj(addEduSync);

  function addEduSync (fb, enc, next) {
    console.log('Add eduSync to Firebase.');

    fb.child('eduSync')
      .set({}, onComplete);

    function onComplete (error) {
      if (error) {
        throw new Error(error);
      }
      next(null, fb);
    }
  }
}

function ApplySyncProtocolToSources (sourcePrototypes) {
  var SyncProtocol = require('../syncProtocol.js');

  return through.obj(fbref);

  function fbref (fb, enc, next) {
    console.log('Applying sync protocol to sources.');

    var stream = this;

    sourcePrototypes
      .map(configure)
      .forEach(pushInto(stream));

    next();

    function configure (source) {
      SyncProtocol(source, fb);
      return source();
    }
    function pushInto (stream) {
      return function pusher (source) {
        stream.push(source);
      };
    }
  }
}

function GetSourcesData () {
  return through.obj(getSourceData);

  function getSourceData (source, enc, next) {
    console.log(
      'Get all data from source & put into firebase.');

    source.errors = [];

    if (('listSource' in source) &&
        ('sourceStreamToFirebaseSource' in source)) {

      pump(
        source.listSource(),
        source.sourceStreamToFirebaseSource(),
        end);
    }
    else {
      end(true);
    }

    function end (err) {
      var stepError = new Error('Could not get source data.');
      if (err) {
        source.errors
          .push(stepError);

        if (err instanceof Error) {
          source.push(err);
        }
      }
      next(null, source);
    }
  }
}

function AddSourceToWebhook () {
  return through.obj(addSource);

  function addSource (source, enc, next) {
    console.log('Add source data to webhook data.');

    if ((source.errors.length === 0) &&
        ('listFirebaseSource' in source) &&
        ('addSourceToWebhook' in source)) {
      pump(
        source.listFirebaseSource(),
        source.addSourceToWebhook(),
        end);
    }
    else {
      end(true);
    }

    function end (err) {
      var stepError = new Error(
        'Could not add source data to webhook data');
      if (err) {
        source.errors
          .push(stepError);

        if (err instanceof Error) {
          source.push(err);
        }
      }
      next(null, source);
    }
  }
}

function RemoveFromWebhookBasedOnSource () {
  /**
   * List the webhook and source values
   * if the webhook value is not in the
   * source values, invoke the model's
   * `webhookValueNotInSource`
   */
  return through.obj(remove);

  function remove (source, enc, next) {
    console.log('Remove from WebHook based on source.');
    
    if ((source.errors.length === 0) &&
        ('listFirebaseWebhook' in source) &&
        ('addInSourceBool' in source) &&
        ('updateWebhookValueNotInSource' in source)) {
      pump(
        source.listFirebaseWebhook(),
        source.addInSourceBool(),
        source.updateWebhookValueNotInSource(),
        end);
    }
    else {
      end(true);
    }

    function end (err) {
      var stepError = new Error(
        'Could not remove from webhook based on source.');
      if (err) {
        source.errors
          .push(stepError);

        if (err instanceof Error) {
          source.push(err);
        }
      }
      next(null, source);
    }
  }
}

function ResolveRelationships () {
  return through.obj(relationships);

  function relationships (source, enc, next) {
    console.log('Resolve Relationships.');

    if ((source.errors.length === 0) &&
        ('rrListWebhookWithRelationshipsToResolve' in source) &&
        ('rrGetRelatedData' in source) &&
        ('rrResetRelated' in source) &&
        ('rrEnsureReverseRootNode' in source) &&
        ('rrEnsureReverseContenTypeNode' in source) &&
        ('rrEnsureReverseContentTypeValueNode' in source) &&
        ('rrEnsureReverseKeyNode' in source) &&
        ('rrPopulateRelated' in source) &&
        ('rrSaveReverse' in source) &&
        ('rrSaveCurrent' in source)) {
      pump(
        source.rrListWebhookWithRelationshipsToResolve(),
        source.rrGetRelatedData(),
        source.rrResetRelated(),
        source.rrEnsureReverseRootNode(),
        source.rrEnsureReverseContenTypeNode(),
        source.rrEnsureReverseContentTypeValueNode(),
        source.rrEnsureReverseKeyNode(),
        source.rrPopulateRelated(),
        source.rrSaveReverse(),
        source.rrSaveCurrent(),
        end);
    }
    else {
      end(true);
    }

    function end (err) {
      var stepError = new Error(
        'Could not resovle relationships.');
      if (err) {
        source.errors
          .push(stepError);

        if (err instanceof Error) {
          source.push(err);
        }
      }
      next(null, source);
    }
  }
}

function ResolveReverseRelationships () {
  return through.obj(reverse);

  function reverse (source, enc, next) {

    if ((source.errors.length === 0) &&
        ('rrrListRelationshipsToResolve' in source) &&
        ('rrrAddData' in source) &&
        ('rrrFormatData' in source) &&
        ('rrrSave' in source)) {
      pump(
        source.rrrListRelationshipsToResolve(),
        source.rrrAddData(),
        source.rrrFormatData(),
        source.rrrSave(),
        end);
    }
    else {
      end(true);
    }


    function end (err) {
      var stepError = new Error(
        'Could not resovle relationships.');
      if (err) {
        source.errors
          .push(stepError);

        if (err instanceof Error) {
          source.push(err);
        }
      }
      next(null, source);
    }
  }
}

function Exit () {
    return through.obj(exit);

    function exit (row, enc, next) {
        next(null);
        process.exit();
    }
}
