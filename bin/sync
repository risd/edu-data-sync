#!/usr/bin/env node

var fs = require('fs');
var through = require('through2');
var pump = require('pump');
var parseArgs = require('minimist');

var Env = require('../env.js');
var Firebaseref = require('../firebaseref.js');

var Events = require('../sources/events/index.js');
var Employees = require('../sources/employees/index.js');
var Courses = require('../sources/courses/index.js');

var sourcePrototypes = [];

var Report = require('../report/index.js')();

// Based on arguments passed into this process
// populate the sources that will be sync'd.
var args = parseArgs(process.argv.slice(2));
if (args._.indexOf('help') > -1) {
    var usage = fs.readFileSync(
                    __dirname +
                    '/syncUsage.md')
                .toString()
                .replace(/```/g, '\n');
    console.log(usage);
    return;
}
if (args._.length === 0) {
    sourcePrototypes.push(Events);
    sourcePrototypes.push(Employees);
    sourcePrototypes.push(Courses);
} else {
    var largs = args._
                    .map(function (d) {
                        return d.toLowerCase();
                    });

    if (largs.indexOf('events') > -1) {
        sourcePrototypes.push(Events);
    }
    if (largs.indexOf('employees') > -1) {
        sourcePrototypes.push(Employees);
    }
    if (largs.indexOf('courses') > -1) {
        sourcePrototypes.push(Courses);
    }
}

Env();

Firebaseref()
    .pipe(AddEduSyncNodeToFirebase())
    .pipe(Report.config())
    .pipe(ApplySyncProtocolToSources(sourcePrototypes))
    .pipe(GetSourcesData())
    .pipe(AddSourceToWebHook())
    .pipe(RemoveFromWebhookBasedOnSource())
    .pipe(ResolveRelationships())
    .pipe(ResolveReverseRelationships())
    .pipe(Report.update())
    .pipe(Exit());


function AddEduSyncNodeToFirebase () {
    return through.obj(addEduSync);

    function addEduSync (fb, enc, next) {
        console.log('Add eduSync to Firebase.');

        fb.child('eduSync')
          .set({}, onComplete);

        function onComplete (error) {
            if (error) {
                throw new Error(error);
            }
            next(null, fb);
        }
    }
}

function ApplySyncProtocolToSources (sourcePrototypes) {
    var SyncProtocol = require('../syncProtocol.js');

    return through.obj(fbref);

    function fbref (fb, enc, next) {
        console.log('Applying sync protocol to sources.');

        // PICKUP
        // have this push out individual source
        // prototypes.
        // have the following streams, expect a single
        // prototype, that will use pump() to pipe
        // together the functions for each one
        // that way errors can propogate
        var sources = sourcePrototypes.map(configure);
        next(null, sources);

        function configure (source) {
            SyncProtocol(source, fb);
            return source();
        }
    }
}

function GetSourcesData () {
    return through.obj(getSourceData);

    function getSourceData (sources, enc, next) {
        var m =
            'Get all data from sources & put into firebase.';
        console.log(m);

        var stream = this;
        var getters = sources
            .map(function (source) {
                return source.listSource()
                    .pipe(source.sourceStreamToFirebaseSource());
            });

        var getterCount = getters.length;
        if (getterCount === 0) {
            next(null, sources);
        }
        else {
            getters.forEach(function (getter) {
                getter.on('data', function () {});
                getter.on('error', function (err) {
                    next(null, []);
                });
                getter.on('end', function checkDone () {
                    getterCount -= 1;
                    if (getterCount === 0) {
                        next(null, sources);
                    }
                });
            });
        }
    }
}

function AddSourceToWebHook () {
    return through.obj(addSource);

    function addSource (sources, enc, next) {
        console.log('Add source data to webhook data.');

        var stream = this;
        var adders = sources
            .map(function (source) {
                return source.listFirebaseSource()
                    .pipe(source.addSourceToWebhook());
            });

        var addersCount = adders.length;
        if (addersCount === 0) {
            next(null, sources);
        }
        else {
            adders.forEach(function (adder) {
                adder.on('data', function () {});
                adder.on('error', function () {
                    next(null, []);
                });
                adder.on('end', function checkDone () {
                    addersCount -= 1;
                    if (addersCount === 0) {
                        next(null, sources);
                    }
                });
            });
        }
    }
}

function RemoveFromWebhookBasedOnSource () {
    /**
     * List the webhook and source values
     * if the webhook value is not in the
     * source values, invoke the model's
     * `webhookValueNotInSource`
     */
    return through.obj(remove);

    function remove (sources, enc, next) {
        console.log('Remove from WebHook based on source.');
        var stream = this;

        var removers = sources
            .map(function (source) {
                return source.listFirebaseWebhook()
                    .pipe(source.addInSourceBool())
                    .pipe(source.updateWebhookValueNotInSource());
            });

        var removersCount = removers.length;
        if (removersCount === 0) {
            next(null, []);
        }
        else {
            removers.forEach(function (remover) {
                remover.on('data', function () {});
                remover.on('end', function () {
                    removersCount -= 1;
                    if (removersCount === 0) {
                        next(null, sources);
                    }
                });
            });
        }
    }
}

function ResolveRelationships () {
    return through.obj(relationships);

    function relationships (sources, enc, next) {
        console.log('Resolve Relationships.');

        var stream = this;

        var resolvers = sources
            .map(function (source) {
                return source.rrListWebhookWithRelationshipsToResolve()
                    .pipe(source.rrGetRelatedData())
                    .pipe(source.rrResetRelated())
                    .pipe(source.rrEnsureReverseRootNode())
                    .pipe(source.rrEnsureReverseContenTypeNode())
                    .pipe(source.rrEnsureReverseContentTypeValueNode())
                    .pipe(source.rrEnsureReverseKeyNode())
                    .pipe(source.rrPopulateRelated())
                    .pipe(source.rrSaveReverse())
                    .pipe(source.rrSaveCurrent());
            });

        var resolversCount = resolvers.length;
        if (resolversCount === 0) {
            next(null, sources);
        }
        else {
            resolvers.forEach(function (resolver) {
                resolver.on('data', function () {});
                resolver.on('end', function () {
                    resolversCount -= 1;
                    if (resolversCount === 0) {
                        next(null, sources);
                    }
                });
            });
        }
    }
}

function ResolveReverseRelationships () {
    return through.obj(reverse);

    function reverse (sources, enc, next) {
        var stream = this;

        var resolvers = sources
            .map(function (source) {
                return source.rrrListRelationshipsToResolve()
                    .pipe(source.rrrAddData())
                    .pipe(source.rrrFormatData())
                    .pipe(source.rrrSave());
            });

        var resolversCount = resolvers.length;
        if (resolversCount === 0) {
            next(null, sources);
        }
        else {
            resolvers.forEach(function (resolver) {
                resolver.on('data', function () {});
                resolver.on('end', function () {
                    resolversCount -= 1;
                    if (resolversCount === 0) {
                        next(null, sources);
                    }
                });
            });
        }
    }
}

function Exit () {
    return through.obj(exit);

    function exit (row, enc, next) {
        next(null);
        process.exit();
    }
}
